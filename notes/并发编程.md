# 并发编程

## 1. 进程与线程

### 1.1 进程与线程

#### 进程

- 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理IO的
- 当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程
- 进程就可以视为程序的一个实例。大部分程序可以用来同时运行多个实例进程（例如：记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如：网易云音乐、360安全卫士等）

#### 线程

- 一个进程之内可以分为一到 多个线程
- 一个线程就是一个指令流，将指令流中的一条条指令以一定顺序交给 CPU执行
- java中，线程作为最小调度单位，进程作为资源分配的最小单位。在 windows中进程是不活动的，只是作为线程的容器

#### 二者对比

- 进程基本上相互独立的，而线程存在于进程内，是进程的一个子集
- 进程拥有共享的资源，如内存空间等，供其内部的线程共享
- 进程间通信较为复杂
  - 同一台计算机的进程通信称为 IPC(Inter-process communication)
  - 不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 http
- 线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量
- 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低

### 1.2 并行与并发

单核cpu下，线程实际还是**串行执行**的。操作系统中有一个组件叫做任务调度器，将cpu的时间片（windows下时间片最小约为15毫秒）分给不同的线程使用，只是由于 cpu在线程间（时间片很短）的切换非常快，人类感觉是同时运行的。总结就是：**微观串行，宏观并行**

一般将*这种线程轮流使用 cpu*的做法称为**并发** (**concurrent**)

| CPU  | 时间片1 | 时间片2 | 时间片3 | 时间片4 |
| ---- | ------- | ------- | ------- | ------- |
| core | 线程1   | 线程2   | 线程3   | 线程4   |

![concurrent](http://119.3.210.172:8080/api/view/7aaa236b3874184c90007f4d2891975fe04f0dcb7e7161b8c36b89a8bd35d94d)

多核cpu下，每个核（core）都可以调度运行线程，这时候线程可以是并行的

| CPU   | 时间片1 | 时间片2 | 时间片3 | 时间片4 |
| ----- | ------- | ------- | ------- | ------- |
| core1 | 线程1   | 线程1   | 线程3   | 线程3   |
| core2 | 线程2   | 线程4   | 线程2   | 线程4   |

![parallel](http://119.3.210.172:8080/api/view/d1cc355426ab9c9c51ed2a089ca0045e997a384113a31e7077ba75fa36dba9fc)

引用 Rob Pike的一段描述：

- 并发（concurrent）是同一时间应对（dealing with）多件事件的能力
- 并行（parallel）是同一时间动手做（doing）多件事件的能力

### 1.3 应用

#### 应用之异步调用（案例一）

从方法的调用角度来讲，如果

- 需要等待结果返回，才能继续运行就是**同步**
- 不需要等待结果返回，就能继续执行就是**异步**

注意：同步在多线程中还有另外一层意思，是让多个线程步调一致

##### 1）设计

多线程可以让方法执行变成异步的，比如说读取磁盘文件时，假设读取操作花费了5秒，如果没有线程调度机制，这5秒调用者什么都做不了，其代码都得暂停

##### 2）结论

- 比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程
- tomcat的异步 servlet也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞 tomcat的工作线程
- ui程序中，开线程进行其他操作，避免阻塞ui线程

#### 应用之提高效率（案例一）

充分利用多核 cpu的优势，提高运行效率。执行3个计算，最后将计算结果汇总

```
计算 1花费 10ms
计算 2花费 11ms
计算 3花费 9ms
汇总需要 1ms
```

- 如果串行执行，那么总花费时间是 10 + 11 + 9 + 1 = 31ms

- 如果是四核 cpu，各个核心分别使用线程1执行计算1，线程2执行计算2，线程3执行计算3，那么3个线程是并行的，花费时间只取决于最长的那个线程运行时间，即 11ms，最后加上汇总时间总共是 12ms

  > 注意：需要在多核cpu才能合格提高效率，单核仍然是轮流执行

##### 1）设计

- 使用 **JMH**

##### 2）结论

1. 单核 cpu下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程流程使用cpu，不至于一个线程总占用cpu，别的线程没法干活
2. 多核 cpu可以并行跑多个线程，但能否提高程序运行效率还是要分情况的
   - 有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任务都能拆分（参考【阿姆达尔定律】）
   - 也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率则没有意义
3. IO操作不占用cpu，只是我们一般拷贝文件使用的是【阻塞IO】，这时相当于线程虽然不用 cpu，但需要一直等待 IO结束，没能充分利用线程。所有才有后面的【非阻塞IO】和【异步IO】优化

## 2. Java线程

### 2.1 创建和运行线程

#### 方法一：直接使用Thread

```java
// 1. 创建线程对象，匿名类
Thread t = new Thread() {
  @Override
  public void run() {
    // 要执行的任务
  }
}

// 2.调用线程
t.setName("t1"); // 可选，为线程设置名称
t.start();

/**
  * 例子：打印
  */
public class Test1 {
  public static void mian(String[] args) {
    Thread t1 = new Thread() {
      @Override
      public void run() {
        System.out.println("hello from thread 1");
      }
    }
    t1.setName("t1");
    t1.start();
    System.out.println("hello from main");
  }
}
// 输出：
// "hello from thread 1"
// "hello from main"
```

#### 方法二：使用Runnable配合Thread

把【线程】和【任务】（要执行的代码）分开

- Thread代表线程
- Runnable可运行的任务

```java
// 1. 创建 Runable实例
// 1.1 匿名类方式
Runnable runnable = new Runnable() {
  @Override
  public void run () {
    // 要执行的任务
  }
}
// 1.2 lambda方式
Runnable runnable = () -> {
  // 要执行的任务
};
// 2. 创建 Thread实例，二参可选，为线程的名称
Thread t = new Thread(runnable, [name]);
// 3. 启动线程
t.start();

/**
  * 例子：打印
  */
public class Test2 {
  public static void mian(String[] args) {
    Runnable r1 = new Runnable() {
      @Override
      public void run() {
        System.out.println("hello from thread 2");
      }
    }
    Thread t2 = new Thread(r1, "t2");
    t2.start();

    System.out.println("hello from main");
  }
}
// 输出：
// "hello from thread 2"
// "hello from main"
```

> @FunctionalInterface注解
>
> 只有一个抽象方法的接口会拥有该注解，比如：Runnable接口
>
> 拥有该注解的接口可以使用 lambda表达式实现

#### *原理之 Thread与 Runnable的关系

**Runnable源码**

runnable方式实际会在`new Thread`时被 init方法赋值给 target变量，最后在 run方法中判断 target是否存在，存在则调用` target.run()`

**小结**

- 方法1是把线程和任务合并在一起，方法2是把线程和任务分开了
- 用 Runnable更容易与线程池等高级API配合
- 用 Runnable让任务类脱离了 Thread继承体系，更灵活

#### 方法三：FutureTask配合Thread

FutureTask能够接收 Callable类型的参数，用来处理有返回结果的情况

```java
// 创建任务对象
FutureTask<Integer> task1 = new FutureTask<>(() -> {
  System.out.println("hello from thread 3");
  // 主线程会等待 task运行结束
  Thread.sleep(2000);
  return 100;
});

// 参数 1是任务对象，参数 2是线程名称
new Thread(task1, "t3");

// 主线程阻塞，同步等待 task执行完毕的结果
Integer result = task1.get();
System.out.println("结果是 {}".format(result));

// 输出：
// "hello from thread 3"
// 结果是 100
```

### 2.2 观察多个线程同时运行

- 交替执行
- 谁先谁后执行，由cpu任务调度控制

### 2.3 查看进程线程的方法

#### windows

- 任务管理器可以查看进程和线程数，也可以用来杀死进程
- `tasklist`查看进程
- `taskkill /F /PID <pid>`杀死进程

#### linux

- `ps -fe`查看所有进程
- `ps -fT -p <pid>`查看某个进程（PID）的所有线程
- `kill <pid>`杀死进程
- `top`按大写 H切换是否显示线程
- `top -H -p <pid>`查看某个进程（PID）的所有线程

#### Java

- `jps`命令查看所有 Java进程

- `jstack <pid>`查看某个java进程（PID）的所有线程状态（只是某个时刻的快照）

- `jconsole`来查看某个 java进程中线程的运行情况（图形化界面）

  - 远程监控需要配置

    1. 需要以如下方式运行 java类

       ```shell
       java -Djava.rmi.server.hostname=ip地址 \
       	-Dcom.sun.management.jmxremote \
       	-Dcom.sun.management.jmxremote.port=连接端口 \
       	-Dcom.sun.management.jmxremote.ssl=是否安全连接 \ # true或 false
       	-Dcom.sun.management.jmxremote.authenticate=是否认证 \ # true或 false
       	java类
       ```

    2. 修改 /etc/hosts文件将 127.0.0.1映射至主机名

  - 如果要认证访问，还需要做如下步骤
    1. 复制 jmxremote.password文件
    2. 修改 jmxremote.password和 jmxremote.access文件的权限为 600，即文件所有者可读写
    3. 连接时填入 controlRole(用户名)，R&D(密码)

### 2.4 *原理之线程运行

### 2.5 常见方法

### 2.6 start方法详解

#### 调用 run

#### 调用 start

#### 小结

### 2.7 yield与 sleep

#### sleep

#### yield

#### 线程优先级

#### *应用之效率（案例二）

### 2.8 join方法详解

#### 为什么需要 join

#### *应用之同步（案例一）

#### 等待多个结果




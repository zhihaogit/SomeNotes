# 并发编程

## 1. 进程与线程

### 1.1 进程与线程

#### 进程

- 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理IO的
- 当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程
- 进程就可以视为程序的一个实例。大部分程序可以用来同时运行多个实例进程（例如：记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如：网易云音乐、360安全卫士等）

#### 线程

- 一个进程之内可以分为一到 多个线程
- 一个线程就是一个指令流，将指令流中的一条条指令以一定顺序交给 CPU执行
- java中，线程作为最小调度单位，进程作为资源分配的最小单位。在 windows中进程是不活动的，只是作为线程的容器

#### 二者对比

- 进程基本上相互独立的，而线程存在于进程内，是进程的一个子集
- 进程拥有共享的资源，如内存空间等，供其内部的线程共享
- 进程间通信较为复杂
  - 同一台计算机的进程通信称为 IPC(Inter-process communication)
  - 不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 http
- 线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量
- 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低

### 1.2 并行与并发

单核cpu下，线程实际还是**串行执行**的。操作系统中有一个组件叫做任务调度器，将cpu的时间片（windows下时间片最小约为15毫秒）分给不同的线程使用，只是由于 cpu在线程间（时间片很短）的切换非常快，人类感觉是同时运行的。总结就是：**微观串行，宏观并行**

一般将*这种线程轮流使用 cpu*的做法称为**并发** (**concurrent**)

| CPU  | 时间片1 | 时间片2 | 时间片3 | 时间片4 |
| ---- | ------- | ------- | ------- | ------- |
| core | 线程1   | 线程2   | 线程3   | 线程4   |

![concurrent](https://obs-bucket-zino-1.obs.cn-north-4.myhuaweicloud.com/images/7aaa236b3874184c90007f4d2891975fe04f0dcb7e7161b8c36b89a8bd35d94d.png)

多核cpu下，每个核（core）都可以调度运行线程，这时候线程可以是并行的

| CPU   | 时间片1 | 时间片2 | 时间片3 | 时间片4 |
| ----- | ------- | ------- | ------- | ------- |
| core1 | 线程1   | 线程1   | 线程3   | 线程3   |
| core2 | 线程2   | 线程4   | 线程2   | 线程4   |

![parallel](https://obs-bucket-zino-1.obs.cn-north-4.myhuaweicloud.com/images/d1cc355426ab9c9c51ed2a089ca0045e997a384113a31e7077ba75fa36dba9fc.png)

引用 Rob Pike的一段描述：

- 并发（concurrent）是同一时间应对（dealing with）多件事件的能力
- 并行（parallel）是同一时间动手做（doing）多件事件的能力

### 1.3 应用

#### 应用之异步调用（案例一）

从方法的调用角度来讲，如果

- 需要等待结果返回，才能继续运行就是**同步**
- 不需要等待结果返回，就能继续执行就是**异步**

注意：同步在多线程中还有另外一层意思，是让多个线程步调一致

##### 1）设计

多线程可以让方法执行变成异步的，比如说读取磁盘文件时，假设读取操作花费了5秒，如果没有线程调度机制，这5秒调用者什么都做不了，其代码都得暂停

##### 2）结论

- 比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程
- tomcat的异步 servlet也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞 tomcat的工作线程
- ui程序中，开线程进行其它操作，避免阻塞ui线程

#### 应用之提高效率（案例一）

充分利用多核 cpu的优势，提高运行效率。执行3个计算，最后将计算结果汇总

```
计算 1花费 10ms
计算 2花费 11ms
计算 3花费 9ms
汇总需要 1ms
```

- 如果串行执行，那么总花费时间是 10 + 11 + 9 + 1 = 31ms

- 如果是四核 cpu，各个核心分别使用线程1执行计算1，线程2执行计算2，线程3执行计算3，那么3个线程是并行的，花费时间只取决于最长的那个线程运行时间，即 11ms，最后加上汇总时间总共是 12ms

  > 注意：需要在多核cpu才能合格提高效率，单核仍然是轮流执行

##### 1）设计

- 使用 **JMH**

##### 2）结论

1. 单核 cpu下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程流程使用cpu，不至于一个线程总占用cpu，别的线程没法干活
2. 多核 cpu可以并行跑多个线程，但能否提高程序运行效率还是要分情况的
   - 有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任务都能拆分（参考【阿姆达尔定律】）
   - 也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率则没有意义
3. IO操作不占用cpu，只是我们一般拷贝文件使用的是【阻塞IO】，这时相当于线程虽然不用 cpu，但需要一直等待 IO结束，没能充分利用线程。所有才有后面的【非阻塞IO】和【异步IO】优化

## 2. Java线程

### 2.1 创建和运行线程

#### 方法一：直接使用Thread

```java
// 1. 创建线程对象，匿名类
Thread t = new Thread() {
  @Override
  public void run() {
    // 要执行的任务
  }
}

// 2.调用线程
t.setName("t1"); // 可选，为线程设置名称
t.start();

/**
  * 例子：打印
  */
public class Test1 {
  public static void mian(String[] args) {
    Thread t1 = new Thread() {
      @Override
      public void run() {
        System.out.println("hello from thread 1");
      }
    }
    t1.setName("t1");
    t1.start();
    System.out.println("hello from main");
  }
}
// 输出：
// "hello from thread 1"
// "hello from main"
```

#### 方法二：使用Runnable配合Thread

把【线程】和【任务】（要执行的代码）分开

- Thread代表线程
- Runnable可运行的任务

```java
// 1. 创建 Runable实例
// 1.1 匿名类方式
Runnable runnable = new Runnable() {
  @Override
  public void run () {
    // 要执行的任务
  }
}
// 1.2 lambda方式
Runnable runnable = () -> {
  // 要执行的任务
};
// 2. 创建 Thread实例，二参可选，为线程的名称
Thread t = new Thread(runnable, [name]);
// 3. 启动线程
t.start();

/**
  * 例子：打印
  */
public class Test2 {
  public static void mian(String[] args) {
    Runnable r1 = new Runnable() {
      @Override
      public void run() {
        System.out.println("hello from thread 2");
      }
    }
    Thread t2 = new Thread(r1, "t2");
    t2.start();

    System.out.println("hello from main");
  }
}
// 输出：
// "hello from thread 2"
// "hello from main"
```

> @FunctionalInterface注解
>
> 只有一个抽象方法的接口会拥有该注解，比如：Runnable接口
>
> 拥有该注解的接口可以使用 lambda表达式实现

#### *原理之 Thread与 Runnable的关系

**Runnable源码**

runnable方式实际会在`new Thread`时被 init方法赋值给 target变量，最后在 run方法中判断 target是否存在，存在则调用` target.run()`

**小结**

- 方法1是把线程和任务合并在一起，方法2是把线程和任务分开了
- 用 Runnable更容易与线程池等高级API配合
- 用 Runnable让任务类脱离了 Thread继承体系，更灵活

#### 方法三：FutureTask配合Thread

FutureTask能够接收 Callable类型的参数，用来处理有返回结果的情况

```java
// 创建任务对象
FutureTask<Integer> task1 = new FutureTask<>(() -> {
  System.out.println("hello from thread 3");
  // 主线程会等待 task运行结束
  Thread.sleep(2000);
  return 100;
});

// 参数 1是任务对象，参数 2是线程名称
new Thread(task1, "t3");

// 主线程阻塞，同步等待 task执行完毕的结果
Integer result = task1.get();
System.out.println("结果是 {}".format(result));

// 输出：
// "hello from thread 3"
// 结果是 100
```

### 2.2 观察多个线程同时运行

- 交替执行
- 谁先谁后执行，由cpu任务调度控制

### 2.3 查看进程线程的方法

#### windows

- 任务管理器可以查看进程和线程数，也可以用来杀死进程
- `tasklist`查看进程
- `taskkill /F /PID <pid>`杀死进程

#### linux

- `ps -fe`查看所有进程
- `ps -fT -p <pid>`查看某个进程（PID）的所有线程
- `kill <pid>`杀死进程
- `top`按大写 H切换是否显示线程
- `top -H -p <pid>`查看某个进程（PID）的所有线程

#### Java

- `jps`命令查看所有 Java进程

- `jstack <pid>`查看某个java进程（PID）的所有线程状态（只是某个时刻的快照）

- `jconsole`来查看某个 java进程中线程的运行情况（图形化界面）

  - 远程监控需要配置

    1. 需要以如下方式运行 java类

       ```shell
       java -Djava.rmi.server.hostname=ip地址 \
       	-Dcom.sun.management.jmxremote \
       	-Dcom.sun.management.jmxremote.port=连接端口 \
       	-Dcom.sun.management.jmxremote.ssl=是否安全连接 \ # true或 false
       	-Dcom.sun.management.jmxremote.authenticate=是否认证 \ # true或 false
       	java类
       ```

    2. 修改 /etc/hosts文件将 127.0.0.1映射至主机名

  - 如果要认证访问，还需要做如下步骤
    1. 复制 jmxremote.password文件
    2. 修改 jmxremote.password和 jmxremote.access文件的权限为 600，即文件所有者可读写
    3. 连接时填入 controlRole(用户名)，R&D(密码)

### 2.4 *原理之线程运行

#### 栈与栈帧

Java Virtual Machine Stacks（Java虚拟机栈）

JVM中由堆、栈、方法区所组成，其中栈内存是线程在使用，每个线程启动后，虚拟机都会为其分配一块栈内存

- 每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存
- 每个线程只能有一个活动帧，对应着当前正在执行的那个方法

![主线程栈帧运行示意图](https://obs-bucket-zino-1.obs.cn-north-4.myhuaweicloud.com/images/%E6%88%AA%E5%B1%8F2022-04-12%20%E4%B8%8B%E5%8D%887.37.41-2022-04-12-93794ed067e2612c20d8acb1f2e9aaff-f7a5de.png)

#### 线程上下文切换（Thread Context Switch）

因为以下原因导致cpu不再执行当前的线程，转而执行另一个线程的代码

- 线程的cpu时间片用完
- 垃圾回收
- 有更高优先级的线程需要运行
- 线程自己调用了 sleep、yield、wait、join、park、synchronized、lock等方法程序

当Context switch发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条jvm指令的执行地址，是线程私有的

- 状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等
- Context switch频繁发生会影响性能

### 2.5 常见方法

| 方法名 static           | 功能说明                                                     | 注意                                                         |
| ----------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| start()                 | 启动一个新线程，在新线程运行 run方法中的代码                 | start方法只是让线程进入就绪，里面代码不一定立马运行（cpu的时间片还没分给它）。每个线程对象的start方法只能调用一次，多次调用则会 IllegalThreadStateException |
| run()                   | 新线程启动后会调用的方法                                     | 如果在构造Thread对象时传递了Runnable参数，则线程启动后会调用Runnable中的run方法，否则默认不执行任何操作。但可以创建Thread的子类对象，来覆盖默认行为 |
| join()                  | 等待线程运行结束                                             |                                                              |
| join(long n)            | 等待线程运行结束，最多等待 n毫秒                             |                                                              |
| getId()                 | 获取线程长整型的id                                           | id唯一                                                       |
| getName()               | 获取线程名                                                   |                                                              |
| setName(String)         | 设置线程名                                                   |                                                              |
| getPriority()           | 获取线程优先级                                               |                                                              |
| setPriority(int)        | 设置线程优先级                                               | java中线程优先级为1~10的整数，较大的优先级能提高被cpu调度的几率 |
| getState()              | 获取线程状态                                                 | Java中线程状态是用6个enum表示，分别是NEW,RUNNABLE,BLOCKED,WAITING,TIMED_WAITING,TERMINATED |
| isInterrupted()         | 判断是否被打断                                               | 不会清除**打断标记**                                         |
| isAlive()               | 线程是否存活（还没有运行完毕）                               |                                                              |
| interrupt()             | 打断线程                                                     | 如果被打断线程正在 sleep，wait，join会导致被打断的线程抛出 InterruptedException，并清除**打断标记**。如果打断的正在运行的线程，则会设置**打断标记**。park的线程被打断，也会设置**打断标记** |
| interrupted()  static   | 判断当前线程是否被打断                                       | 会清除**打断标记**                                           |
| currentThread()  static | 获取当前正在执行的线程                                       |                                                              |
| sleep(long n)  static   | 让当前执行的线程休眠n毫秒，休眠时间内让出 cpu时间片给其它线程 |                                                              |
| yield()  static         | 提示线程调度器让出当前线程对cpu的使用                        | 主要是为了测试和调试                                         |

### 2.6 start与run

#### 调用 run

不调用`thread.start()`，直接调用 `thread.run()`方法，线程内的代码会在 main线程中运行，而不是在新建的线程中执行

#### 调用 start

- 在 `thread.start()`运行前后，`thread.getState()`分别输出**NEW**,**RUNNABLE**
- 重复多次调用同一个线程的 `thread.start()`，会抛出IllegalThreadStateException

### 2.7 yield与 sleep

#### sleep

- 调用 `sleep`会让当前线程从**Runnable**进入 **Timed Waiting**阻塞状态
- 其它线程可以使用 `interrupt`方法打断正在睡眠的线程，这时 `sleep`方法会抛出InterruptedException
- 睡眠结束后的线程未必会立刻得到执行
- 建议用 `TimeUnit`的 `sleep`方法(如：`TimeUnit.SECONDS.sleep(1)`)代替 `Thread`的 `sleep`来获得更好的可读性

#### yield

- 调用 `yield`会让当前线程从**Running**进入**Runnable**就绪状态，然后调度执行其它同优先级的线程。如果这时没有同优先级的线程，那么不能保证让当前线程展厅的效果
- 具体的实现依赖于操作系统的任务调度器

#### 线程优先级

- 线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它
- 如果cpu比较忙，那么优先级高的线程会获得更多的时间片，但 cpu闲时，优先级几乎无作用

#### 案例-防止cpu占用100%

在没有利用 cput来计算时，不要让 while(true)空转浪费cpu，这时可以使用 yield或 sleep来让出 cpu的使用权给其它程序

```java
while(true) {
  try {
    Thread.sleep(50);
  } catch(InterruptedException e) {
    e.printStackTrace();
  }
}
```

- 使用 wait和条件变量也能达到类似效果
- 但需要加锁
- sleep适用于无需锁同步的场景

### 2.8 join方法详解

#### 为什么需要 join

#### *应用之同步（案例一）

#### 等待多个结果



